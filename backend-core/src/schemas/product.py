from datetime import datetime
from typing import Optional, List
from pydantic import BaseModel, Field, ConfigDict, computed_field

# --- 기본 상품 스키마 ---
class ProductBase(BaseModel):
    name: str = Field(..., min_length=2, max_length=255, examples=["AI Leather Jacket"])
    description: Optional[str] = Field(None, examples=["A cool jacket generated by AI."])
    price: int = Field(..., ge=0, examples=[150000])
    stock_quantity: int = Field(..., ge=0, examples=[10])
    category: Optional[str] = Field(None, examples=["Outerwear"])
    image_url: Optional[str] = None

class ProductCreate(ProductBase):
    gender: Optional[str] = Field(None, examples=["Unisex"])
    embedding: Optional[List[float]] = None        # BERT 벡터 (768차원)
    embedding_clip: Optional[List[float]] = None   # CLIP 벡터 (512차원) - 신규 추가

class ProductUpdate(ProductBase):
    name: Optional[str] = None
    price: Optional[int] = None
    stock_quantity: Optional[int] = None
    gender: Optional[str] = None
    embedding: Optional[List[float]] = None
    embedding_clip: Optional[List[float]] = None

class ProductResponse(ProductBase):
    id: int
    gender: Optional[str] = None
    created_at: datetime
    updated_at: datetime
    
    # [FIX] DB 컬럼이 아닌 계산된 필드로 변경하여 에러 방지
    @computed_field
    def in_stock(self) -> bool:
        return self.stock_quantity > 0

    model_config = ConfigDict(from_attributes=True)

# --- 검색 관련 스키마 ---
class SearchQuery(BaseModel):
    query: str = Field(..., min_length=1, description="검색어")
    min_price: Optional[int] = Field(None, ge=0, description="최소 가격")
    max_price: Optional[int] = Field(None, ge=0, description="최대 가격")
    category: Optional[str] = Field(None, description="카테고리")

# --- AI 기능 관련 스키마 ---
class LLMQueryBody(BaseModel):
    question: str

class CoordinationResponse(BaseModel):
    answer: str
    products: List[ProductResponse]